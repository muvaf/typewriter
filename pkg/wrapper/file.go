// Copyright 2021 Muvaffak Onus
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package wrapper

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"text/template"

	"github.com/pkg/errors"

	"github.com/muvaf/typewriter/pkg/packages"
)

func LinterEnabled() FileOption {
	return func(f *File) {
		f.LinterEnabled = true
	}
}

func WithImports(im *packages.Imports) FileOption {
	return func(f *File) {
		f.Imports = im
	}
}

func WithHeaderPath(h string) FileOption {
	return func(f *File) {
		f.HeaderPath = h
	}
}

func WithGenStatement(s string) FileOption {
	return func(f *File) {
		f.GenStatement = s
	}
}

type FileOption func(*File)

func NewFile(pkgPath, pkgName, tmpl string, opts ...FileOption) *File {
	f := &File{
		PackageName:  pkgName,
		Template:     tmpl,
		Imports:      packages.NewImports(pkgPath, pkgName),
		GenStatement: "// Code generated by typewriter. DO NOT EDIT.",
	}
	for _, fn := range opts {
		fn(f)
	}
	return f
}

type File struct {
	HeaderPath    string
	GenStatement  string
	Template      string
	PackageName   string
	LinterEnabled bool
	Imports       *packages.Imports
}

// Wrap writes the objects to the file one by one.
func (f *File) Wrap(input map[string]interface{}) ([]byte, error) {
	importStatements := ""
	for p, a := range f.Imports.Imports {
		// We always use an alias because package name does not necessarily equal
		// to that the last word in the path, hence it's not completely safe to
		// not use an alias even though there is no conflict.
		importStatements += fmt.Sprintf("%s \"%s\"\n", a, p)
	}
	header, err := ioutil.ReadFile(f.HeaderPath)
	if err != nil {
		return nil, errors.Wrap(err, "cannot read header file")
	}
	values := map[string]interface{}{
		"Header":       string(header),
		"GenStatement": f.GenStatement,
		"Imports":      importStatements,
		"PackageName":  f.PackageName,
	}
	for k, v := range input {
		values[k] = v
	}
	t, err := template.New("file").Parse(f.Template)
	if err != nil {
		return nil, errors.Wrap(err, "cannot parse template")
	}
	result := &bytes.Buffer{}
	if err := t.Execute(result, values); err != nil {
		return nil, errors.Wrap(err, "cannot execute template")
	}
	if f.LinterEnabled {
		outb := bytes.NewBuffer([]byte{})
		errOut := bytes.NewBuffer([]byte{})
		shellCmd := exec.Command("goimports")
		shellCmd.Stdin = result
		shellCmd.Stdout = outb
		shellCmd.Stderr = errOut
		if err := shellCmd.Run(); err != nil {
			return nil, errors.Wrapf(err, "goimports failed: %s", errOut.String())
		}
		result = outb
	}
	return result.Bytes(), nil
}

// Write wraps the file with given input and writes it to the file system.
func (f *File) Write(name string, input map[string]interface{}, perm os.FileMode) error {
	if err := os.MkdirAll(filepath.Dir(name), perm); err != nil {
		return errors.Wrap(err, "cannot mkdir directory of the file")
	}
	data, err := f.Wrap(input)
	if err != nil {
		return errors.Wrap(err, "cannot wrap file")
	}
	return errors.Wrap(os.WriteFile(name, data, perm), "cannot write file")
}
